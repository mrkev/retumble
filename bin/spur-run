#!/usr/bin/env node

const program       = require('commander');
const express       = require('express');
const fs            = require('fs-extra');
const get_remote    = require('request-promise');
const app           = express();
const path          = require('path');
const webpack       = require('webpack');
const config        = require('./webpack.config')(process.cwd())
const compiler      = webpack(config);
const devMiddleware = require('webpack-dev-middleware');
const hotMiddleware = require('webpack-hot-middleware');
const extract       = require('../src/lib/extract')
const str           = require('../src/lib/string')
const localhost     = require('ip').address()
var cors = require('cors')
app.use(cors())
var tmp = require('tmp');


/** Program mcjiggs */

program
  .usage('<options> [index]')
  .option('-s, --source [path]', 'Use custom remote source')
  .parse(process.argv);

const remote_url = program.args[0]  || 'http://digi123.tumblr.com'
const themefile  = program.source || path.resolve(__dirname, 'index.html')

/** Delimits the blog object in a react theme. */
const bobj_del = '/*586f3690*/';

/** Gets local file */
const get_local = url => new Promise((res, rej) => {
  console.log('   * getting local', url)
  fs.readFile(url, 'utf8', (err, data) => {
    if (err) rej(err)
    else res(data)
  })
})

const local_theme = fs.readFileSync(themefile, 'utf8')

/** Webpack mcjiggs */

app.use(require('webpack-dev-middleware')(compiler, {
  publicPath: config.output.publicPath,
  noInfo: true,
  historyApiFallback: true,
}));

app.use(require('webpack-hot-middleware')(compiler));


const cache_file = path.join('.', 'cache.json')
fs.ensureFileSync(cache_file)
const cache = fs.readJsonSync(cache_file, {throws: false}) || {}
const tmpobj = tmp.dirSync();

const get_remote_memo = uri => {
  if (!cache[uri]) return get_remote(uri)
    .then(file => {
      cache[uri] = file
      return file
    })
  else {
    console.log(' * Cache hit!')
    fs.writeJsonSync(cache_file, cache)
    return Promise.resolve(cache[uri])
  }
}

app // Route all requests to remote equivalent
.get(/.*/, function (req, res) {
  console.log(` > requested ${req.path}`)
  /**
   * We fetch. If path exist on remote, we return
   * that, otherwise, we fall back to local files.
   */
  get_remote_memo(remote_url + req.path)
  .catch(e => {
    // TODO: Check if is /, if thats the case,
    // its a faulty interent connection
    console.log(` - no remote ${req.path}`)

    return get_local(req.path)
  })
   /**
    * If we fetched a themefile (from remote)
    * we take its info and put it in the local
    * themefile.
    */
  .then(file => {
    if (!extract.isTheme(file)) { return file }
    else {
      const middle = file && str.replaceAll(
        extract.t_string_from_html(file),
        remote_url, `http://${localhost}:8080`)
      return middle
        ? str.revert(local_theme, bobj_del, bobj_del, middle)
        : local_theme;
    }
  })
  .then(r => {
    console.log(` v returning something for ${req.path}`)
    res.type('html');
    res.send(r);
  })
  .catch(x => {
    console.error(x)
    res.status(404).send('Not found')
  })
})

app.listen(8080, function () {
  console.log(`
    Testing server listening on ${localhost}:4410 (localhost)
    > theme: ${themefile}
    > src: ${remote_url}
    `);
});

